[요구사항 확인]
    <운영체제 관련 요구사항 식별 시 고려사항>
        *가용성
        *성능
        *기술 지원
        *주변 기기
    </운영체제 관련 요구사항 식별 시 고려사항>

    <DBMS_DataBase Management System, 데이터베이스 관리 시스템>
        <DBMS 관련 요구사항 식별 시 고려사항>
        *가용성
        *성능
        *기술 지원
        *상호 호환성
        *구축 비용
    </DBMS>

    *WAS <Web Application Server, 동적인 컨텐츠, 미들웨어>

    *오픈 소스 <소스 코드 공개, 소프트웨어>

    *기능, 비기능, 사용자, 시스템 <요구사항 유형>
    *도출>분석>명세>확인 <요구사항 개발 프로세스>
    *요구사항 분류, 개념 모델링, 요구사항 할당, 요구사항 협상, 정형 분석 <요구사항 분석 기법>
    *요구사항 검토, 프로토타이핑, 모델 검증, 인수 테스트 <요구사항 확인 기법>

    *UML <Unified Modeling Language 객체지향 모델링 언어, 시스템 개발자와 고객의 상호 의사소통>
    *컴포넌트, Component 문서, 소스코드, 파일, 라이브러리와 같은 재사용이 가능한 모듈화된 자원
    <UML 관계, 클래스 다이어그램>
        *연관 관계 <Association, ->위에 숫자>
        *집합 관계 <Aggregation, ◇화살표, 독립적임>
        *포함 관계 <Composition, ◆화살표, 의존적임>
        *일반화 관계 <Gerneralization, ▷화살표, 상하위개념>
        *의존 관계 <Dependency, ...>, 영향을 미침>
        *실체화 관계 <Realization, ...▷, 그룹화>
    </UML 관계>

    <다이어그램, 사물 관계를 도형으로 표시>
        <구조적 다이어그램, 정적 모델링>
            *클래스 다이어그램 <UML 관계 사용>
            *객체 다이어그램
            *컴포넌트 다이어그램
            *복합체 구조 다이어그램
            *패키지 다이어그램
        </구조적 다이어그램>

        <행위 다이어그램, 동적 모델링>
            *유스케이스 다이어그램 <액터, 유스케이스, 포함, 확장, 일반화>
            *시퀀스 다이어그램 <객체가 메모리에 존재하는 기간으로 나눔>
            *커뮤니케이션 다이어그램 <객체들이 메세지를 주고받음>
            *상태 다이어그램 <객체들의 상태 변화>
            *활동 다이어그램 <흐름에 따라 순서대로 표시>
            *상호작용 개요 다이어그램
            *타이밍 다이어그램
        </행위 다이어그램>
    </다이어그램>
[/요구사항 확인]

[데이터 입출력 구현]
    <데이터 모델, 단순화, 추상화하여 표현한 개념적 모형>
        *개념적 데이터 모델 <현실 세계에 대한 인식을 추상적으로>
        *논리적 데이터 모델 <컴퓨터 세계에 맞도록 변환>
    </데이터 모델>

    <데이터 모델의 구성 요소>
        *개체, Entity 현실 세계
        *속성, Attribute 가장 작은 논리적 단위
        *관계, Relationship 논리적 연결
    </데이터 모델의 구성 요소>

    <데이터 모델에 표시할 요소>
        *구조, Structure
        *연산, Operation
        *제약 조건, Constraint
    </데이터 모델에 표시할 요소>

    <이상, Anomaly>
        *삽입 이상, Insertion Anomaly
        *삭제 이상, Deletion Anomaly
        *갱신 이상, Update Anomaly
    </이상>

    <정규화, Normalization 테이블을 무손실 분해하는 과정>
        *1정규화, 테이블 모든 속성이 원자값
        *2정규화, 완전 함수적 종속
        *3정규화, 이행적 함수적 종속이 아닌 것
        *BCNF, 모든 결정자가 후보 키
        *4정규화, 다중 값 종속
        *5정규화, 조인 종속
    </정규화>
    *반정규화, 의도적으로 정규화 원칙을 위배하는 행위

    <인덱스, 키 값, 포인터 쌍으로 구성>
        *클러스터드 인덱스 <인덱스 키의 순서대로 저장>
        *넌클러스터드 인덱스 <키 값만 정렬, 실제 데이터는 안정렬>
        *트리 기반 인덱스 <트리 구조>
        *비트맵 인덱스 <0 과 1>
        *함수 기반 인덱스
        *비트맵 조인 인덱스 <다수의 조인된 객체>
        *도메인 인덱스 <개발자가 직접 만듬>
        *결합 인덱스 <여러 컬럼을 하나의 인덱스로>
    </인덱스>
    *멀티 블록 리드, Multi Block Read 테이블 접속 시 한 번에 부를 수 있는 블록 개수

    *뷰, View 허용된 자료를 보여주기 위해 이름을 가지는 가상 테이블

    *클러스터, Cluster 엑세스 효율 향상을 위해 동일 데이터를 동일 블록에 저장하는 물리적 저장 방법
    *클러스터링 키, Clustering Key 클러스터링된 블록 헤드에 있는 키 값

    <파티션, Partition 테이블이나 인덱스를 작은 논리적 단위로 나누는 것>
        *범위 분할 <열 값을 기준>
        *해시 분할 <해시 함수 결과 기준>
        *조합 분할 <범위 사용 후 해시 분할>
    </파티션>
    *인덱스 파티션, 파티션 테이블에 인덱스 부여
[/데이터 입출력 구현]

[통합 구현]
    *통합 구현 개념, 송수신 모듈과 중계 모듈 간의 연계를 구현
    
    *연계 요구사항 분석, 연계 데이터를 표준화하여 정의

    *ISP_Internet Service Providers, 인터넷 서비스 업체
    *Protocol, 프로토콜, 표준화시킨 통신 규약

    <연계 데이터 식별 및 표준 절차>
        *연계 범위 및 항목 정의
        *연계 코드 변환 및 매핑
        *연계 데이터 식별자와 변경 구분 추가
        *연계 데이터 표현 방법 정의
        *연계 정의서 및 명세서 작성
    </연계 데이터 식별 및 표준 절차>
    *직접 연계, 송수신 시스템 없이 연계
    *간접 연계, 중간에 매개체 두어 연계

    *API_Application Programming Interface, 프로그램 개발 시 라이브러리를 이용할 수 있게 규칙을 정의한 인터페이스
    *Socket, 포트를 할당하여 클라이언트와 연결하여 통신하는 네트워크 기술

    *패킷, Packet 수신측 주소와 제어 정보가 포함된 데이터 블록
    *VPN_Virtual Private Network, 공중 네트워크에 암호화 기술을 이용하여 전용 회선처럼 사용하게 해주는 보안 솔루션

    *해시, Hash 임의의 메세지를 고정된 길이의 값이나 키로 변환하는 것

    <EAI_Enterprise Application Integration, 송수신 데이터를 제어하고 처리하는 시스템>
        *Point-to-Point <1:1 연결>
        *Hub & Spoke <중앙집중형>
        *Message Bus <미들웨어>
        *Hybrid <Hub & Spoke + Message Bus>, 데이터 병목 현상 최소화
    </EAI>
    *ESB_Enterprise Service Bus, 표준 기반의 인터페이스를 제공

    *SOA_Service Oriented Architecture, 서비스 지향 아키텍처, 컴포넌트 중심으로 구축하는 정보기술 아키텍처
    <Web Service, WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 방식>
        *WSDL_Web Service Description Language 웹 서비스, 프로토콜을 표준 방식으로 게시하기 위한 언어
        *UDDI_Universal Description~Discovery and Integration, 전세계 비즈니스 목록에 자신의 목록을 두기 위한 xml 기반 규칙
        *SOAP_Simple Object Access Protocol, 웹 서비스를 실제로 이용하기 위한 객체간 통신 규약
    </Web Service>

    *XML_eXtensible Markup Language, SGML의 복잡함과 호환성 문제를 해결하기 위한 다목적 마크업 언어
    *SGML_Stand Generalized Markup Language, 멀티미디어 전자문서를 손실없이 처리하기 위한 언어

    <연계 테스트, 연계 시스템이 정상적으로 동작하는지 확인>
        *연계 테스트 케이스 작성
        *연계 테스트 환경 구축
        *연계 테스트 수행
        *연계 테스트 수행 결과 검증
    </연계 테스트>
[/통합 구현]

[서버 프로그램 구현]
    <개발 언어의 선정 기준>
        *적정성
        *효율성
        *이식성
        *친밀성
        *범용성
    </개발 언어의 선정 기준>

    <하드웨어 환경>
        <Web Server>
            <종류>
            *Apache HTTP Server
            *Microsoft Internet Information Service
            *Google Web Server

            <기능>
            *HTTP/HTTPS 지원
            *통신 기록
            *정적 파일 관리
            *대역폭 제한
            *가상 호스팅
            *인증
        </Web Server>

        <WAS>
            <종류>
            *Apache Tomcat
            *IBM WebSphere
            *Oracle WebLogic
        </WAS>

        <File Server>
            <종류>
            *AWS
            *S3
        </File Server>
    </하드웨어 환경>

    <소프트웨어 환경>
        <요구사항 관리 도구>
            *JIRA
            *IBM DOORS
            *inteGREAT
            *Reqitify
            *Trello
        </요구사항 관리 도구>

        <설계/모델링 도구>
            *DB Designer
            *PlantUML
            *ArgoUML
        </설계/모델링 도구>

        <구현 도구>
            *Eclipse
            *IntelliJ IDEA
            *Visual Studio
            *Netbeans
            *Node.js
        </구현 도구>

        <빌드 도구>
            *Ant
            *Gradle
            *Maven
            *Jenkins
        </빌드 도구>

        <테스트 도구>
            *CppUnit
            *JUnit
            *HttpUnit
            *NUnit
            *SpringTest
        </테스트 도구>
    </소프트웨어 환경>

    <모듈, 분리된 각 시스템의 기능, 서브루틴, 서브시스템, 작업 단위 등>
        <공통 모듈 명세 기법>
            *정확성
            *명확성
            *완전성
            *일관성
            *추적성
        </공통 모듈 명세 기법>
        *재사용, reuse 모듈을 재활용

        <결합도>
            *자료
            *스탬프
            *제어
            *외부
            *공통
            *내용
        </결합도>

        <응집도>
            *기능적
            *순차적
            *교환적
            *절차적
            *시간적
            *논리적
            *우연적
        </응집도>

        *Fan-in, 시스템 구조도에서 특정 모듈이 제어하는 개수
        *Fan-out, 시스템 구조도에서 특정 모듈이 호출하는 개수
    </모듈>

    <DBMS, 데이터 사용을 위해 DB에 접근하기 위한 매개체>
        *JDBC, 자바 표준 API
        *ODBC, 마이크로소프트 표준 API
        *MyBatis, JDBC를 강화해주는 프레임워크
    </DBMS>
    *Dynamic SQL, NVL과 같은 함수 없이도 값을 자동으로 넣는 동적 처리 방식

    <서버 개발 프레임워크>
        <특성>
        *모듈화, 품질 향상
        *재사용성, 생산성 향상
        *확장성, 다형성 활용
        *제어의 역흐름, 객체 권한을 프레임워크로

        <종류>
        *Spring, 자바 기반
        *Node.js, 자바스크립트 기반
        *Django, 파이썬 기반
        *Codeigniter, PHP 기반
        *Ruby on Rails, Ruby 기반
    </서버 개발 프레임워크>

    <서버 개발 과정>
        *DTO/VO 구현, 데이터 교환을 위해 사용할 객체 제작
        *SQL 구현, SQL문 생성
        *DAO 구현, 데이터베이스 접그을 위한 코드 구현
        *Service 구현, 요청에 응답하기 위한 로직
        *Controller 구현, 사용자에게 반환하기 위한 로직
    </서버 개발 과정>

    <배치 프로그램, Batch program 미리 작성한 일련의 작업을 순서에 따라 일괄 처리>
        *스프링 배치, 스프링 기반, 공동개발
        *Quartz, 스프링 스케줄러 도구
        *Cron, 리눅스 스케줄러 도구
    </배치 프로그램>
[/서버 프로그램 구현]

[화면 설계]
    <사용자 인터페이스 UI 구분>
        *CLI, 텍스트
        *GUI, 마우스
        *NUI, 목소리 행동 등
    </사용자 인터페이스 UI 구분>

    <UI 기본 원칙>
        *직관성
        *유효성
        *학습성
        *유연성
    </UI 기본 원칙>

    <UI 설계 도구>
        *와이어프레임, 기본 뼈대
        *목업, 디자이너들이 사용, 정적
        *스토리보드, 페이지간 이동 흐름
        *프로토타입, 인터랙션, 동적
        *유스케이스, 사용자 입장
    </UI 설계 도구>

    <UI 스타일 가이드>
        *구동 환경 정의
        *레이아웃 정의
        *네비게이션 정의
        *기능 정의
        *구성 요소 정의
    </UI 스타일 가이드>

    <UI 프로토타입 종류>
        *페이퍼, 아날로그 방법
        *디지털, 파워포인트, 아크로뱃, 비지오, 옴니그래플 등으로 제작
    </UI 프로토타입 종류>
[/화면 설계]

[애플리케이션 테스트 관리]
    <테스트 케이스의 기본 원리>
        *결함 집중, Defect Clusting, 애플리케이션 결함은 대부분 특정 모듈에 집중되어 있다.
        *파레토의 법칙, 20%의 코드에서 80%의 결함이 발견된다는 법칙
        *살충제 패러독스, Pesticide Paradox 동일한 테스트 케이스로 동일 테스트를 반복하면 더이상 결함이 나오지 않음
        *오류 부재의 궤변, Absence of Errors Fallacy 오류가 없어도 사용자 요구사항을 만족시키지 못하면 품질이 높지 않다는 것
    </테스트 케이스의 기본 원리>

    <화이트박스 테스트, 원시 코드 오픈 상태>
        *기초 경로 검사, 대표적인 방법, 설계자가 논리적 복잡성을 측정하게 하는 방법
        <제어 구조 검사>
            *조건 검사, 모듈 내 논리적 조건 검사
            *루프 검사, 반복 구조 검사
            *데이터 흐름 검사, 변수 정의와 위치 검사
        </제어 구조 검사>
    </화이트박스 테스트>

    <검증 기준, Coverage>
        *기능 기반 커버리지, 전체 기능 수
        *라인 커버리지, 실행된 라인 수
        *코드 커버리지, 구문, 분기, 조건 등의 코드
    </검증 기준, Coverage>

    <블랙박스 테스트, 구현된 각 기능들 테스트>
        *동치 분할 검사, 입력 자료에 초점
        *경계값 분석, 입력 조건의 경계값에 초점
        *원인-효과 그래프 검사, 데이터의 관계, 출력에 따른 효용성으로 테스트 케이스 선정
        *오류 예측 검사, 확인자의 과거 경험과 감각에 의존
        *비교 검사, 여러 버전에 동일 자료를 제공하는 검사
    </블랙박스 테스트>
    
    <테스트 프로세스>
        *테스트 계획
        *테스트 분석 및 디자인
        *테스트 케이스 및 시나리오 작성
        *테스트 수행
        *테스트 결과 평가 및 리포팅
        <결함 추적 및 관리>
            *에러 발견
            *에러 등록
            *에러 분석
            *결함 확정
            *결함 할당
            *결함 조치
            *결함 검토 및 승인
        </결함 추적 및 관리>
    </테스트 프로세스>

    <테스트 케이스>
        *테스트 계획 검토 및 자료 확보
        *위험 평가 및 우선순위 결정
        *테스트 요구사항 정의
        *테스트 구조 설계 및 테스트 방법 결정
        *테스트 케이스 정의
        *테스트 케이스 타당성 확인 및 유지 보수
    </테스트 케이스>

    *테스트 시나리오, 테스트 케이스를 묶은 집합

    <테스트 오라클, 참 값을 대입하여 테스트>
        <기능>
        *제한된 검증
        *수학적 기법
        *자동화 기능

        <종류>
        *참 오라클, 발생한 모든 오류 검출
        *샘플링 오라클, 입력 값들에 대해서만 결과 제공
        *추정 오라클, 입력 값들은 결과 제공, 나머지는 추정하여 결과 제공
        *일관성 검사 오라클, 전후의 결과값이 동일한지 비교
    </테스트 오라클>

    <테스트 자동화 도구>
        *정적 분석 도구, 프로그램 실행 안하고 코드만 분석
        *테스트 실행 도구, 스크립트 언어로 테스트
        *성능 테스트 도구, 가상의 사용자를 만들어 테스트
        *테스트 통제 도구, 형상 관리 도구, 결함 추적/관리 도구
        <테스트 하네스 도구, 컴포넌트 및 모듈 테스트>
            *테스트 드라이버, 하위 모듈 호출
            *테스트 스텁, 타 모듈 단순 호출
            *테스트 슈트, 컴포넌트와 모듈, 테스트 케이스의 집합
            *테스트 케이스, 테스트 항목 명세서
            *테스트 스크립트, 테스트 실행 절차 명세서
            *목 오브젝트, 상황을 미리 설정하여 예정된 행동을 수행하는 객체
        </테스트 하네스 도구>
    </테스트 자동화 도구>

    <결함 관리 프로세스>
        *결함 관리 계획
        *결함 기록
        *결함 검토
        *결함 수정
        *결함 재확인
        *결함 상태 추적 및 모니터링 활동
        *최종 결함 분석 및 보고서 작성
    </결함 관리 프로세스>

    <결함 추적 순서>
        *결함 등록
        *결함 검토
        *결함 수정
        *결함 수정
        *결함 조치 보류
        *결함 종료
        *결함 해제
    </결함 추적 순서>

    <애플리케이션 성능 측정 지표>
        *처리량
        *응답 시간
        *경과 시간
        *자원 사용률
    </애플리케이션 성능 측정 지표>

    <애플리케이션 성능 테스트 도구>
        *Jmeter, HTTP,FTP
        *LoadUI, HTTP,JDBC
        *OpenSTA, HTTP, HTTPS
    </애플리케이션 성능 테스트 도구>

    <애플리케이션 시스템 모니터링 도구>
        *Scouter, 단일 튜닝에 최적화
        *Zabbix
    </애플리케이션 시스템 모니터링 도구>

    <애플리케이션 성능 분석 절차>
        *애플리케이션 성능 점검을 위해 성능 테스트 도구와 시스템 모니터링 도구의 유형을 파악하고 그 특징을 정리한다.
        *성능 점검의 개요, 수행 전략, 수행 일정 및 절차, 수행 방식 등을 포함하여 애플리케이션 성능 점검 계획서를 작성한다.
        *애플리케이션 성능 측정을 위한 테스트 케이스를 작성한다.
        *애플리케이션 성능 테스트를 수행한다.
        *애플리케이션의 성능 테스트 결과를 분석한다.
        *애플리케이션의 성능 저하 요인을 찾아 분석한다.
    </애플리케이션 성능 분석 절차>

    <클린 코드 작성 원칙>
        *가독성
        *단순성
        *의존성 배제
        *중복성 최소화
        *추상화
    </클린 코드 작성 원칙>

    <소스 코드 품질 분석 도구>
        <정적 분석 도구, 코드 실행하지 않고 분석>
            *pmd, 미사용 변수, 최적화 안된 코드 분석
            *cppcheck, C/C++의 메모리 누수 분석
            *SonarQube, 중복, 복잡도, 코딩 설계 분석
            *checkstyle, JAVA코드 분석
            *ccm, 다양한 언어 복잡도 분석
            *cobertura, JAVA의 복잡도와 테스트 커버리지
        </정적 분석 도구>

        <동적 분석 도구, 코드 실행하여 분석>
            *Avalanche, STP 기반
            *Valgrind, 메모리 및 스레드 결함 분석
        </동적 분석 도구>
    </소스 코드 품질 분석 도구>
[/애플리케이션 테스트 관리]

[SQL 응용]
    <SQL 종류>
        <DDL_Data Define Language>
            *CREATE
            *ALTER
            *DROP
        </DDL>
        <DML_Data Manipulation Language>
            *SELECT
            *INSERT
            *UPDATE
            *DELETE
        </DML>
        <DCL_Data Control Language>
            *GRANT / REVOKE
            *COMMIT
            *ROLLBACK
            *SAVEPOINT
        </DCL>
    </SQL 종류>

    <프로시저, Procedure 트랜잭션 언어>
        <선언>
        CREATE OR REPLACE PROCEDURE 프로시저이름(파라미터 이름 IN 자료형)
        IS
        BEGIN
            UPDATE 급여 SET 지급방식 'S' WHERE 사원번호 = 프로시저이름;
            EXCEPTION
                WHEN PROGRAM_ERROR THEN
                ROLLBACK;
        COMMIT;
        END;

        <호출, 셋 중에 하나>
        EXECUTE 프로시저이름;
        EXEC 프로시저이름;
        CALL 프로시저이름;

        <제거>
        DROP PROCEDURE 프로시저이름;
    </프로시저>

    <트리거, Trigger 시스템에서 DML이 일어날 때마다 자동 수행되는 절차형 SQL>
        <선언>
        CREATE OR REPLACE TRIGGER 트리거이름[동작시기 옵션][동작 옵션] ON 테이블명
        REFERENCING [NEW|OLD] AS 테이블명
        FOR EACH ROW
        [WHEN 조건식]
        BEGIN
            트리거 BODY;
        END;

        <제거>
        DROP TRIGGER 트리거이름;
    </트리거>

    <사용자 정의 함수, 프로시저와 유사하게 일련의 작업을 연속으로 처리>
        <선언>
        CREATE OR REPLACE FUNCTION 함수이름(파라미터)
        [지역변수 선언]
        BEGIN
            사용자 정의 함수 BODY;
            RETURN 반환값;
        END;

        <실행>
        SELECT 함수명 FROM 테이블명;
        INSERT INTO 테이블명(속성명) VALUES (함수명);
        UPDATE 테이블명 SET 속성명 = 함수명;
        DELETE FROM 테이블명 WHERE 속성명 = 함수명;

        <제거>
        DROP FUNCTION 함수명;
    <사용자 정의 함수>

    <커서, 메모리 공간을 가리키는 포인터>
        *묵시적 커서
        *명시적 커서
    </커서>
[/SQL 응용]

[소프트웨어 개발 보안 구축]
    <소프트웨어 개발 보안 목표>
        *기밀성
        *무결성
        *가용성
    </소프트웨어 개발 보안 목표>
    *소프트웨어 개발 생명주기, SDLC_Software Development Life Cycle <소프트웨어 개발 방법론 표준>
    *Secure SDLC, SDLC에 보안 강화 프로세스를 포함한 것

    <보안 요소>
        *기밀성
        *무결성
        *가용성
        *인증
        *부인 방지
    </보안 요소>
    *시큐어 코딩, 보안 설계에 맞게 코딩하는 방법

    <보안 약점 종류>
        *SQL 삽입, 무단으로 SQL 삽입, 예약어 이용 방지
        *경로 조작 및 자원 삽입, 서버 자원을 수정, 삭제하는 것 /\ 이용 방지
        *크로스 사이트 스크립팅, 악의적 스크립트 삽입, <> 이용 방지
        *운영체제 명령어 삽입, 시스템 명령어 실행 유도, 검증 후 실행
        *위험한 형식 파일 업로드, 악의적 명렁어가 포함된 파일 업로드, 확장자 제한
    </보안 약점 종류>

    <보안 공격 종류 및 보안 시스템>
        *IDS(Intrusion Detection System, 침입 탐지 시스템)   정보 시스템의 보안을 위협하는 침입 행위가 발생할 경우 이를 탐지, 적극 대응하기 위한 시스템
        *DMZ(비무장지대)   내부 네트워크와 외부 사이에 위치하며 외부 인터넷에 서비스를 제공사는 서버를 위치시키기에 가장 적합한 장소
        *DLP(Data Loss Prevention, 데이터 유출 방지)   기업 내부자의 고의나 실수로 인한 외부로의 정보 유출을 방지하는 솔루션
        *웹 방화벽(Web Firewall)   일반 방화벽이 탐지하지 못하는 SQL 삽입 공격, Cross-Site Scripting(XSS) 등의 웹 기반 공격을 방어
        *Anti-DDoS   DDos 차단 보안 솔루션
        *VPN(Virtual Private Network, 가상 사설망)   인터넷망과 같은 공중망을 사설망처럼 이용해 회선 비용을 크게 절감할 수 있는 기업 통신 서비스
        *NAC(Network Access Control, 네트워크 접근 제어)   사전에 인가하지 않은 누리꾼이나 보안 체계를 갖추지 않은 정보기기의 통신망(네트워크) 접속을 적절히 조절하는 일 또는 솔루션, 네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션
        *UTM(Unified Threat Management, 통합 위협 관리)   하나의 장비에 여러 가지 보안 기능을 탑재, 침입 차단 시스템, 가상 사설망 등 다양한 보안 솔루션 기능을 하나로 통합한 보안 솔루션
        *ESM(Enterprise Security Management, 기업 보안 관리)   dl 기종 보안 시스템을 통합 관리, 방화벽, 침입 탐지 시스템, 가상 사설망 등의 보안 솔루션을 하나로 모은 통합 보안 관리 시스템
        *SYN Flooding   SYS 넘치도록 공격, 대량의 SYN(동기 제어 문자, 접속할 때 사용하는 패킷)을 이용해서 타겟 서버의 서비스를 더 이상 사용할 수 없도록 만드는 공격 기법, TCP 3-way handshaking 문제점 이용, 서버는 클라이언트가 ACK 패킷을 보내올 때까지 SYN Received 상태로 일정 시간을 기다려야 함, 서버에 다시 ACK 패킷을 보내야 연결이 되는데, 보내지 않으면 대기 상태가 됨
        *스머핑(Smurfing, ping flood, ping 홍수)   고성능 컴퓨터를 이용해 초당 엄청난 양의 접속 신호를 한 사이트에 집중적으로 보냄으로써 상대 컴퓨터의 서버를 접속 불능 상태로 만들어 버리는 해킹 수법(IP, ICMP 특성 악용)
        *LAND 공격(Local Area Network Denial Attack)   나쁜 상태에 빠지게 하다의 의미, 공격자가 패킷의 출발지 주소나 포트를 임의로 변경하여 출발지와 목적지 주소를 동일하게 함
        *TearDrop 공격   패킷 제어 로직을 악용하여 시스템의 자원을 고갈시키는 공격으로 데이터의 송/수신 과정에서 패킷의 크기가 커 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데, 이 값을 변경시켜 수신 측에서 패킷 재조립시 과부하가 발생하도록 공격
        *DDos(Distributed Denial of Service attack, 분산 서비스 거부 공격)   감염된 대량의 숙주 컴퓨터를 이용해 특정 시스템을 마비시키는 사이버 공격, 공격자는 다양한 방법으로 일반 컴퓨터를 감염(좀비 PC)시켜 공격 대상의 시스템에 다량의 패킷이 무차별로 보내지도록 조정함
        *피싱(Phishing)   개인 정보와 낚시의 합성어로 낚시하듯이 개인 정보를 몰래 빼내는 것
        *큐싱(Qshing)   QR 코드와 피싱의 합성어로 QR 코드를 이용한 해킹
        *스미싱(Smishing)   SMS와 피싱의 결합어로 문자메시지를 이용해서 피싱하는 방법
        *스피어 피싱(spear phishing)   조직 내에 신뢰할만한 발신인으로 위장해 ID 및 패스워드 정보를 요구하는 일종의 피싱 공격
        *사회공학적 해킹   시스템이 아닌 사람들의 심리와 행동 양식을 교묘하게 이용해 원하는 정보를 얻는 공격 기법
        *APT(Advanced Persistent Threat, 지능형 지속 공격)   다양한 IT 기술과 방식들을 이용해 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격을 말함
        *스턱스넷(stuxnet)   독일 지멘스사의 원격 감시 제어 시스템(SCADA)의 제어 소프트웨어에 침투하여 시스템을 마비하게 하는 바이러스, 원자력 발전소와 송, 배전망, 화학공장, 송유, 가스관과 같은 산업 기반 시설에 사용되는 제어 시스템에 침투하여 오작동을 유도하는 명령 코드를 입력해서 시스템을 마비시키는 악성 코드
        *SQL 주입 공격(SQL injection)   웹 클라이언트의 반환 메시지를 이용하여 불법 인증 및 정보를 유출하는 공격, 웹 응용 프로그램에 강제로 SQL 구문을 삽입하여 내부 데이터베이스 서버의 데이터를 유출 및 변조하고 관리자 인증을 우회할 수도 있음
        *무작위 대입 공격(brute force attack, 브루트 포스 공격)   조합 가능한 모든 경우의 수를 다 대입해보는 공격
        *제로 데이 공격(Zero day attack)   시스템의 보안 취약점이 발견된 상태에서 이를 보완할 수 있는 보안 패치가 발표되기 전에 해당 취약점을 이용해 이뤄지는 해킹이나 악성코드 공격.
        *랜섬웨어(Ransomware)   인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 스프레트 시트, 그림 파일 등을 암호화해 열지 못하도록 만든 후 돈을 보내주면 해독용 열쇠 프로그램을 전송해준다며 금품을 요구하는 악성 프로그램
        *트랩도어(Trap Door) = 백 도어(back door)   시스템 보안이 제거된 비밀 통로로, 서비스 기술자나 유지 보수 프로그램 작성자의 엑세스 편의를 위해 시스템 설계자가 고의로 만들어 놓은 시스템의 보안 구멍
        *웜 바이러스(Worm virus)   컴퓨터 바이러스와 달리 다른 프로그램을 감염시키지 않고 자기 자신을 복제하면서 통신망 등을 통해서 널리 퍼짐
        *키로거 공격(Key Logger Attack)   컴퓨터 사용자의 키보드 움직임을 탐지해 ID나 패스워드, 계좌번호, 카드 번호 등과 같은 개인의 중요한 정보를 몰래 빼가는 해킹 공격
        *스니핑(Sniffing)   네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나, 컴퓨터 네트워크 상에 흘러다니는 트래픽을 엿드는 도청장치를 말함
        *스누핑(Snooping)   네트워크상에서 남의 정보를 염탐하여 불법으로 가로채는 행위
        *스푸핑(Spoofing)   승인받은 사용자인 것처럼 속이는 것
        *스위치 재밍(Switch Jamming)   위조된 매체 접근 제어(MAC) 주소를 지속적으로 네트워크로 흘려 보내 스위치 저장 기능을 혼란시켜 더미 허브(dummy hub) 처럼 작동토록 하는 공격
    </보안 공격 종류 및 보안 시스템>

    <TOCTOU 경쟁 조건>
        *검사 시점과 사용 시점을 고려하지 않아 교착상태가 발생
    </TOCTOU 경쟁 조건>

    <널 포인터 역참조>
        *널을 반환하는 값을 포인터로 참조할 경우 발생
    </널 포인터 역참조>

    <캡슐화>
        *속성과 메소드를 하나로 묶는 작업을 의미
    </캡슐화>

    <클래스의 허용 범위>
        *Public, 전체 허용
        *Protected, 자신 및 상속된 자식클래스 허용
        *Private, 자신만 허용
        *Package, 자신 및 자신을 포함한 패키지 허용
    </클래스의 허용 범위>

    *DNS_Domain Name System, 숫자로 된 IP 주소를 사람이 이해하기 쉽게 바꾼 형태

    <개인키 암호화 기법, 동일한 키로 암호화, 복호화>
        <블록 암호화>
        *DES, 미국 NBS에서 개발
        *SEED, 한국인터넷진흥원(KISA)에서 개발
        *AES, 미국 표준 기술 연구소(NIST)에서 개발
        *ARIA, 국정원과 산학연협회가 개발

        <스트림 암호화>
        *LFSR
        *RC4
    </개인키 암호화 기법>

    <공개키 암호화 기법, 서로 다른 키로 암호화, 복호화>
        *RSA, MIT의 리아베스트, 샤미르, 애들먼이 제안
    </공개키 암호화 기법>
[/소프트웨어 개발 보안 구축]

[응용 SW 기초 기술 활용]
    *운영체제, OS 컴퓨터를 편리하게 사용하게 해주는 여러 프로그램의 모임
    <운영체제의 목적>
        *처리 능력
        *반환 시간
        *사용 가능도
        *신뢰도
    </운영체제의 목적>

    <WINDOWS>
        <특징>
        *GUI, 마우스 사용
        *선점형 멀티태스킹, 자원 자동 할당
        *PnP, 하드웨어 자동 구성
        *OLE_Object Linking And Embedding, A 프로그램에서 B로 자유롭게 개체를 옮길 수 있음

        <CLI>
        *DIR, 현재 폴더 파일 표시
        *COPY, 파일 복사
        *DEL, 파일 삭제
        *TYPE, 파일 내용 표시
        *REN, 파일 이름 변경
        *MD, 폴더 생성
        *CD, 폴더 변경
        *CLS, 화면 내용 지움
        *ATTRIB, 파일 속성 변경
        *FIND, 문자열 찾기
        *CHKDSK, 디스크 점검
        *FORMAT, 디스크 포맷
        *MOVE, 파일 이동
    </WINDOWS>

    <UNIX>
        <특징>
        *AT&T 벨 연구소, MIT, Gerneral Electric이 공동 개발
        *대부분이 C언어
        *유료이며 회사에서 주로 사용
        *안정성 좋음
        *커널과 쉘로 나뉨

        <CLI>
        *cat, 파일 내용 표시
        *cd, 폴더 변경
        *chmod, 파일 사용 허가 지정
        *chown, 파일 소유자와 그룹 변경
        *cp, 파일 복사
        *rm, 파일 삭제
        *find, 파일 검색
        *fsck, 파일 검사
        *kill, id로 프로세스 종료
        *killall, 이름으로 프로세스 종료
        *ls, 폴더 속 파일들 표시
        *mkdir, 폴더 생성
        *rmdir, 폴더 제거
        *mv, 파일 이동
        *ps, 프로세스 표시
        *pwd, 폴더 경로를 화면에 표시
        *top, 메모리 사용 현황
        *who, 사용자 표시
    </UNIX>

    <LINUX>
        <특징>
        *리누스 토발즈가 개발
        *UNIX와 완벽 호환
        *오픈 소스, 개발자들이 다양하게 개발 후 재배포 가능

        <CLI>
        *UNIX와 동일
    </LINUX>

    <기억장치 관리>
        <반입Fetch 전략, 언제 주기억장치에 저장할 것인지?>
            *요구 반입, 요구하면
            *예상 반입, 예상해서
        </반입 전략>

        <배치Placement 전략, 어디에 저장할 것인지?>
            *최초 적합, 들어갈 수 있는 첫번째 영역에
            *최적 적합, 가장 잘 맞는 영역에
            *최악 적합, 가장 많이 남는 영역에
        </배치 전략>

        <교체Replacement 전략, 어느 영역에 저장할 것인지?>
            *FIFO, 먼저 들어온 게 먼저 나감
            *OPT
            *LRU, 가장 마지막으로 쓰였던 것이 먼저 나감
            *LFU
            *NUR
            *SCR
        </교체 전략>
    </기억장치 관리>

    <DBMS의 종류>
        *계층형, 트리 구조를 이용
        *망형, 그래프를 이용
        *관계형, 가장 많이 쓰임, 2차원 표를 이용
    </DBMS의 종류>

    *ER모델, 피터 첸이 개발, ERD를 정의함
    <ER 도형>
        * □, 개체 타입
        * ─, 개체 타입과 속성을 연결
        * ◇, 관계 타입
        * ▽, ISA 관계, 상위 개체와 하위 개체의 연결
        * □─◇─□, 개체 타입 간의 연관성
        * ○, 속성
        * ◎, 다중값 속성
        * ○ 속에 ─, 기본키 속성
        * ○ 점선, 유도 속성
        * ○─○─○, 복합 속성
    </ER 도형>

    <릴레이션 Relation, 테이블의 다른 말>
        *속성, 각 행의 머리
        *Degree, 속성의 총 개수
        *튜플, 각 속성들을 가진 한 세트, 실제 데이터
        *Relation Instence, 튜플들의 집합 (= 릴레이션, 릴레이션 외연)
        *카디널리티, 튜플의 총 개수
    </릴레이션>

    <키>
        *슈퍼키, Degree를 모두 슈퍼키라고 함
        *후보키, 유일성과 최소성 만족
        *복합키, 두 키를 조합하여 후보키를 만든 것
        *기본키, NULL값 불인정, 후보키 속성 포함
        *대체키, 기본키를 제외한 나머지 후보키
        *외래키, 다른 릴레이션의 기본키를 참조하는 속성들
    </키>

    <무결성>
        *개체 무결성, NULL값 불인정
        *도메인 무결성, 도메인 영역 내의 값
        *참조 무결성, 외래키 겂은 NULL값이나 기본키 값이어야 함
        *사용자 정의 무결성
        *NULL 무결성, NOT NULL
        *고유 무결성, 각 튜플들이 서로 달라야 함
        *키 무결성, 적어도 하나의 키 있어야 함
        *관계 무결성, 관계의 적절성
    </무결성>

    <네트워크>
        *LAN_Local Area Network, 근거리 통신망, 자원 공유
        *WAN_Wide Area Network, 광대역 통신망, 속도 느림
    </네트워크>

    <인터넷>
        *미 국방성 ARPANET에서 시작
        *유닉스 운영체제 기반
        *TCP/IP 프로토콜 기반
        *브리지, 라우터, 게이트웨이 사용
        *중추 네트워크(백본)로 사용
    </인터넷>

    <IP 주소>
        <IPv4>
        *8비트씩 4부분, 총 32비트
        *A(국가),B(중대형),C(소규모),D(멀티캐스트),E(실험용) Class로 나누어 주소 할당

        <IPv6>
        *16비트씩 8부분, 총 128비트
        *IPv4에 비해 속도가 빠르고 호환성이 뛰어남
        *유니캐스트(1:1), 멀티캐스트(1:N), 애니캐스트(단거리1:1)로 주소 체계를 나눔

        <Domain Name>
        IP주소를 문자로 변환한 것 이러한 역할을 하는 시스템을 DNS라고 함
    </IP 주소>

    <OSI_Open System Interconnection 참조 모델, 개방형 시스템 간 데이터 통신시 필요한 장비 및 처리 방법>
        *물리, 비트, 리피터-허브, RS-232C, X.21
        *데이터링크, 프레임, 브리지-스위치, HDLC, LAPB, MAC, LAPD, PPP
        *네트워크, 패킷, 라우터, X.25, IP
        *전송, 세그먼트, 게이트웨이, TCP, UDP
        *세션, 메세지
        *표현, 메세지
        *응용, 메세지
    </OSI 7계층>
    *MAC, 네트워크 어댑터(NIC)의 고유 번호

    <네트워크 관련 장비>
        <허브>
        *컴퓨터를 연결
        *더미 허브, 단순 연결
        *스위칭 허브, 스마트 연결

        <리피터>
        *신호 증폭 및 반복

        <브리지>
        *컴퓨터 그룹을 연결(LAN)

        <스위치>
        *LAN과 LAN을 연결
        *L2, MAC주소 기반
        *L3, IP주소 기반
        *L4, 로드밸런서 탑재, TCP,UDP 기반
        *L7, TCP, UDP, IP 참조

        <라우터>
        *LAN과 WAN을 연결
        *프로토콜 변환

        <게이트웨이>
        *서로 다른 네트워크 연결, 데이터 출입구
    </네트워크 관련 장비>

    <TCP>
        *신뢰성 있는 연결형 서비스
        *패킷의 다중화, 순서-오류-흐름 제어 수행
    </TCP>

    <IP>
        *데이터그램 기반 비연결형 서비스
        *패킷 분해-조립, 주소 지정, 경로 선택 기능 제공
    </IP>

    <프로토콜 Protocol 구성 요소>
        *구문 syntax
        *의미 Semantics
        *시간 Timing
    </프로토콜 Protocol 구성 요소>

    <TCP/IP 구조>
        <응용 계층 프로토콜, OSI의 응용, 표현, 세션 계층>
            *FTP_File Transfer Protocol, 원격 파일 전송
            *SMTP_Simple Mail Transfer Protocol, 전자 우편 교화
            *TELNET, 가상 터미널로 컴퓨터 원격 제어
            *SNMP_Simple Network Management System, 라우터, 허브의 네트워크 정보를 관리 시스템으로 전송
            *DNS_Domain Name System, 도메인 네임을 IP주소로 매핑
            *HTTP_HyperText Transfer Protocol, WWW에 HTML 문서를 송수신
        </응용 계층 프로토콜>

        <전송 계층 프로토콜, OSI의 전송 계층>
            *TCP_Transmission Control Protocol, 양방향 연결형 서비스, 신뢰성 있는 연결, 1:1만 가능
            *UDP_User Datagram Protocol, 비연결형 서비스, 속도 빠름, 오버헤드 적음, 1:1, 1:N, N:M 가능
            *RTCP_Real-Time Control Protocol, 패킷 전송 품질을 제어하는 프로토콜
        </전송 계층 프로토콜, OSI의 전송 계층>

        <네트워크 계층 프로토콜, OSI의 네트워크 계층>
            *IP_Internet Protocol, 비연결형인 데이터그램 방식 사용, 신뢰성 보장안됨
            *ICMP_Internet Control Message Protocol, 오류 처리, 경로 변경을 위한 제어 메세지 관리용 프로토콜
            *IGMP_Internet Group Management Protocol, 멀티캐스트 그룹 유지를 위해 사용
            *ARP_Address Resolution Protocol, 호스트의 IP 주소를 MAC으로 변경
            *RARP_Reverse Address Resolution Protocol, MAC를 IP주소로 변경
        </네트워크 계층 프로토콜, OSI의 네트워크 계층>

        <네트워크 엑세스 프로토콜, OSI의 물리, 데이터링크 계층>
            *Ethernet_IEEE 802.3, CSMA/CD 방식의 LAN
            *IEEE802, LAN을 위한 표준 Protocol
            *HDLC, 비트 위주의 데이터링크 제어 Protocol
            *X.25, 패킷 교환망을 통한 DTE와 DCE 간 인터페이스를 제공하는 Protocol
            *RS-232C, 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간 인터페이스를 제공하는 Protocol
        </네트워크 엑세스 프로토콜, OSI의 물리, 데이터링크 계층>
    </TCP/IP 구조>

    <패킷 교환 방식>
        <회선 교환 방식, 두 지점을 물리적으로 접속시킴, 기존 전화망>
            *공간 분할 교환 방식, 음성 전화용 교환기, 기계식 접점을 이용
            *시분할 교환 방식, 전자 부품이 갖는 고속성과 디지털 교환 기술을 이용
        </회선 교환 방식>
        
        <패킷 교환 방식, 데이터를 패킷 단위로 잘라 전송, 네트워크 계층>
            *가상 회선 방식, 논리적 가상 통신 회선을 미리 설정하여 순서대로 전송
            *데이터그램 방식, 인접 노드들의 트래픽을 감안하여 무작위로 전송
        </패킷 교환 방식>
    </패킷 교환 방식>

    <라우팅, 최적의 패킷 교환 경로를 설정>
        *RIP_Routing Information Protocol, 가장 많이 사용, 소규모 동종 네트워크에 적합
        *IGRP_Interior Gateway Routing Protocol, RIP를 보완, 중규모 네트워크에 사용
        *OSPF_Open Shortest Path First Protocol, 대규모 네트워크에 사용
        *EGP_Exterior Gateway Protocol, 자율 시스템 간 라우팅 프로토콜
        *BGP_Border Gateway Protocol, EGP를 보완, 자율 시스템 간의 라우팅 프로토콜

        <알고리즘>
        *거리 벡터 알고리즘, 인접한 라우팅의 거리와 방향을 이용하여 최적의 경로를 찾음, RIP, IGRP
        *링크 상태 알고리즘, 라우터들을 파악하여 미리 모든 경로와 대체 경로를 마련, OSPF
    </라우팅>
[/응용 SW 기초 기술 활용]

[제품 소프트웨어 패키징]
    <패키징 작업 순서, 배포용 설치 파일 만드는 법>
        *기능 식별
        *모듈화
        *빌드 진행
        *사용자 환경 분석
        *패키징 및 적용 시험
        *패키징 변경 개선
        *배포
    </패키징 작업 순서>

    <릴리즈 노트 작성 순서, 배포용 파일에 대한 정보를 공유하기 위한 노트>
        *모듈 식별
        *릴리즈 정보 확인
        *릴리즈 노트 개요 작성
        *영향도 체크
        *정식 릴리즈 노트 작성
        *추가 개선 항목 식별
    </릴리즈 노트 작성 순서>

    *디지털 저작권 관리, DRM_Digital Right Management 디지털 콘텐츠 관리 및 보호 기술

    <형상 관리, SCM_Software Configuration Management>
        *소프트웨어 변경 사항을 관리하기 위해 개발된 활동
        
        <분산저장소 방식>
            *CVS_Concurrent Version System, 공동 개발을 위한 소스 코드 버전 관리 시스템
            *SVN_Subversion, CVS를 개선, 아파치 소프트웨어에서 개발
            *GIT, 리누스 토발즈가 개발, 커널 개발 도구로서 사용
        </분산저장소 방식>
    </형상 관리>

    <빌드 자동화 도구>
        *Jenkins, JAVA 기반 오픈 소스, SVN, Git 등 대부분의 형상 관리 도구와 연동이 쉬움, WebUI 제공
        *Gradle, Groovy 기반 오픈 소스, 안드로이드 개발 환경에서 사용
    </빌드 자동화 도구>
[/제품 소프트웨어 패키징]